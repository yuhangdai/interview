并发控制

    读写锁
        读锁(共享锁)：读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻读取同一个资源，互不干扰。
        写锁(排它锁)：写锁是排他的，一个写锁会阻塞其它的读锁和写锁。这样是为了确保写入数据的同时，其它用户读取正在写入的数据。

    锁粒度
        因为写锁是排他的，一旦锁定，其它用户此时无法进行读写操作。因此为了提高并发性，锁定对象的选择就非常重要。

        表锁：锁定整张表
        行级锁：行级锁可以最大程度的支持并发处理，但是同时也带来了最大的锁开销。

事务(ACID)：事务内的语句或者全部执行，或者全部不执行。
    A:atomicity原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚；
    C:Consistency一致性：数据库总是从一个一致性的状态转换到令一个一致性的状态；
    I:isolation隔离性：一个事务所做的修改在最终提交之前，对其它事务是不可见的；
    D:durability持久性：一旦事务提交，则其所做的修改就会永久保存到数据库中。

事务隔离级别
    READ UNCOMMITTED(未提交读)
    一个事务中的修改，即使未提交，对另外事务仍然可见；
        脏读(读取到未提交的事务数据)
    READ COMMITTED(提交读) （其它数据库默认隔离级别）
    一个事务开始时，只能“看见”已经提交的事务所做的修改；
        不可重复读(两次执行同一查询语句，可能得到不同的结果)
    REPEATABLE READ(可重复读) （mysql默认隔离级别）
    该级别保证了同一事务中多次读取同样记录结果一致性，解决了脏读和不可重复读问题，但是却会出现另一个问题
        幻读(当某个事务读物范围内记录同时，其它事务在此范围内插入了数据，当之前的事务再次读取该范围记录时，会产生幻行)
    SERIALIZABLE(可串行化)
    最高隔离级别，强制事务串行执行，避免幻读问题

死锁
    多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。
    多个事务试图已不同的顺序锁定资源时，就会产生死锁现象。

死锁检测和死锁超时机制
    innodb处理死锁的方法是将持有最少排它锁的事务进行回滚

多版本并发控制(MVCC)
MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。
根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

INNODB的MVCC是通过在每行记录后面保存两个隐藏的列实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）
当然存储的并不是实际的时间值，而是系统版本号。

INNODB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。其默认隔离级别是可重复读(REPEATABLE READ)，并且通过间隙锁策略
防止幻读的出现。间隙锁使得INNODB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。

MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作

乐观并发控制
悲观并发控制






