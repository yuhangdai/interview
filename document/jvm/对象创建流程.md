### java对象创建流程

- 类加载检查

当虚拟机遇到new指令时，先从常量池中定位到类的符号引用，
并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有就进行加载过程

- 分配内存

类加载检查通过后，虚拟机将为新生对象分配内存。内存分配方式有两种：**指针碰撞**，**空闲列表**
**选择哪种分配方式由java堆是否规整决定，而java堆是否规整与垃圾收集器是否带有压缩整理功能决定**

指针碰撞  
使用场合：堆内存规整的情况
原理：用过的内存全部整合到一边，没有用过的放在另一边，中间有个分界值指针，分配内存时只需要将指针向未使用方向移动指定大小即可
垃圾收集器：Serial、ParNew

空闲列表  
使用场合：堆内存不规整情况
原理：虚拟机会维护一个可用内存块列表，分配内存时，找一块足够大的内存块分配给对象，然后更新列表记录
垃圾收集器：CMS

**内存分配中的并发问题**
jvm虚拟机会频繁创建对像，而创建对象需要分配内存。不同的线程创建对象时可能会对同一块内存区进行操作，
因此存在线程安全问题，jvm通过两种方式保证线程安全。

``CAS+失败重试``:每次不加锁而是假设没有冲突去执行操作，如果因为冲突导致失败就进行重试，直至成功。
虚拟机通过CAS和失败重试保证更新操作的原子性。
  
``TLAB``：为每一个线程在Eden区分配一块内存，JVM在给线程分配内存时，首先在``TLAB``分配，当对象大于
TLAB剩余空间时，才会采用CAS+失败重试在公共内存区进行分配。

- 初始化零值  
内存分配完成后，虚拟机需要为分配到的内存空间中的变量都初始化零值（不包括对象头），这样确保了对象的实例字段
可以不进行初始赋值就能直接使用。

- 设置对象头  
初始化零值之后，虚拟机需要对对象进行必要设置。如对象是哪个类实例、如何获取对象元数据信息、对象GC分代年龄等
这些信息保存在对象头中。同时对象头保存了其偏向锁标志相关信息

- 执行init方法
上面步骤完成后，在jvm中生成了一个对象，但是此时其所有字段均为默认值。只有执行init方法后
才生成程序需要的完整对象


### 对象在内存中存储结构
- 对象头
    markWord(hash码、分代年龄、锁标志位等)
    类型指针：指向当前对象的类的元数据的指针
    
- 实例数据
    对象真正存储的有效信息
    
- 对其填充

[Java对象在内存的结构](https://juejin.im/post/6844903832833490957)

### 垃圾收集器分类

[HotSpot 虚拟机对象探秘](https://github.com/yuhangdai/JavaGuide/blob/master/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.md)